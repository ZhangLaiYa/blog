<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on ZhangLaiYa</title>
    <link>https://blog-zhanglaiya.vercel.app/tags/mysql/</link>
    <description>Recent content in mysql on ZhangLaiYa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Tue, 23 Aug 2022 14:11:38 +0800</lastBuildDate><atom:link href="https://blog-zhanglaiya.vercel.app/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mysql 事务隔离级别</title>
      <link>https://blog-zhanglaiya.vercel.app/posts/mysql-transaction-isolation-level/</link>
      <pubDate>Tue, 23 Aug 2022 14:11:38 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/posts/mysql-transaction-isolation-level/</guid>
      <description>一、先介绍一下mysql事务隔离级别的几个相关的概念。 1、脏读（Dirty Read）： 脏读是读到了其他事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
2、不可重复读（Nonrepeatable Read）： 读到了其他的事务已提交的数据（不可重复读的重点是修改），事务A查询了一条数据后，事务B对该条数据进行修改，此时当事务A再次查询该数据时，得到的结果与第一次查询的不一致。
3、幻读（Phantom Read）： 读到了其他事务已提交的数据（幻读的重点在于新增或者删除），当事务A第一次读取某个范围记录后，事务B新增了一条记录，事务A在此读取这个范围是会多一条记录导致幻读出现。
二、mysql事务隔离级别 1、读未提交（Read Uncommitted）： 顾名思义，事务A可读取到其他事务未提交的内容，在此级别下脏读、幻读、不可重复读等问题都会出现。
2、读已提交（Read Committed）： 大多数数据库默认的事务隔离机制，解决了脏读的问题，仍存在幻读和不可重复读。
3、可重复读（REPEATABLE READ）： InnoDB引擎的默认事务隔离级别，解决了脏读和不可重复读的问题，但仍然存在幻读的问题。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
4、可串行化（SERIALIZABLE） 最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁，后面的事务需要等待前面事务提交或者rollback。在这个级别，可能导致大量的超时现象和锁竞争。</description>
    </item>
    
  </channel>
</rss>
