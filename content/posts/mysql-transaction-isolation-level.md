---
title: "mysql 事务隔离级别"
date: 2022-08-23T14:11:38+08:00
description: "A blog post"
type: "post"
tags: ["mysql"]
draft: false
---

#### 一、先介绍一下mysql事务隔离级别的几个相关的概念。 
**1、脏读（Dirty Read）**：
脏读是读到了其他事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。  
**2、不可重复读（Nonrepeatable Read）**：
读到了其他的事务已提交的数据`（不可重复读的重点是修改）`，事务A查询了一条数据后，事务B对该条数据进行修改，此时当事务A再次查询该数据时，得到的结果与第一次查询的不一致。  
**3、幻读（Phantom Read）**：
读到了其他事务已提交的数据`（幻读的重点在于新增或者删除）`，当事务A第一次读取某个范围记录后，事务B新增了一条记录，事务A在此读取这个范围是会多一条记录导致幻读出现。

### 二、mysql事务隔离级别

**1、读未提交（Read Uncommitted）：**
顾名思义，事务A可读取到其他事务未提交的内容，在此级别下脏读、幻读、不可重复读等问题都会出现。  
**2、读已提交（Read Committed）：**
大多数数据库默认的事务隔离机制，解决了脏读的问题，仍存在幻读和不可重复读。  
**3、可重复读（REPEATABLE READ）：**
InnoDB引擎的默认事务隔离级别，解决了脏读和不可重复读的问题，但仍然存在幻读的问题。`InnoDB引擎采用了MVCC（多事务版本控制）解决了幻读的问题。`  
**4、可串行化（SERIALIZABLE）**
最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁，后面的事务需要等待前面事务提交或者rollback。在这个级别，可能导致大量的超时现象和锁竞争。  
