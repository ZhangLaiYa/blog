<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZhangLaiYa</title>
    <link>https://blog-zhanglaiya.vercel.app/</link>
    <description>Recent content on ZhangLaiYa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Tue, 23 Aug 2022 14:11:38 +0800</lastBuildDate><atom:link href="https://blog-zhanglaiya.vercel.app/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mysql 事务隔离级别</title>
      <link>https://blog-zhanglaiya.vercel.app/posts/mysql-transaction-isolation-level/</link>
      <pubDate>Tue, 23 Aug 2022 14:11:38 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/posts/mysql-transaction-isolation-level/</guid>
      <description>一、先介绍一下mysql事务隔离级别的几个相关的概念。 1、脏读（Dirty Read）： 脏读是读到了其他事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
2、不可重复读（Nonrepeatable Read）： 读到了其他的事务已提交的数据（不可重复读的重点是修改），事务A查询了一条数据后，事务B对该条数据进行修改，此时当事务A再次查询该数据时，得到的结果与第一次查询的不一致。
3、幻读（Phantom Read）： 读到了其他事务已提交的数据（幻读的重点在于新增或者删除），当事务A第一次读取某个范围记录后，事务B新增了一条记录，事务A在此读取这个范围是会多一条记录导致幻读出现。
二、mysql事务隔离级别 1、读未提交（Read Uncommitted）： 顾名思义，事务A可读取到其他事务未提交的内容，在此级别下脏读、幻读、不可重复读等问题都会出现。
2、读已提交（Read Committed）： 大多数数据库默认的事务隔离机制，解决了脏读的问题，仍存在幻读和不可重复读。
3、可重复读（REPEATABLE READ）： InnoDB引擎的默认事务隔离级别，解决了脏读和不可重复读的问题，但仍然存在幻读的问题。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
4、可串行化（SERIALIZABLE） 最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁，后面的事务需要等待前面事务提交或者rollback。在这个级别，可能导致大量的超时现象和锁竞争。</description>
    </item>
    
    <item>
      <title>Radix</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/radix/</link>
      <pubDate>Fri, 19 Aug 2022 18:14:17 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/radix/</guid>
      <description>def radix_sort(lst, max_value): radix = 0 while max_value: buckets = [[] for _ in range(10)] for i in lst: buckets[(i // (10 ** radix)) % 10].append(i) print(buckets) cur = 0 for i in range(10): for j in buckets[i]: lst[cur] = j cur += 1 max_value //= 10 radix += 1 时间复杂度：
最优：$O(n×k)$
最坏：$O(n×k)$
平均：$O(n×k)$
空间复杂度： $O(n + k)$
稳定性： 稳定</description>
    </item>
    
    <item>
      <title>桶排序</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/bucket/</link>
      <pubDate>Fri, 19 Aug 2022 17:56:09 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/bucket/</guid>
      <description>设置固定数量的空桶；
把数据放到对应的桶中；
对每个不为空的桶中数据进行排序；
拼接不为空的桶中数据，得到结果。
def bucket_sort(lst): max_value = lst[0] min_value = lst[0] for m in lst: if m &amp;gt; max_value: max_value = m if m &amp;lt; min_value: min_value = m # 1. 创建桶（注意：一个桶就是一个列表） bucket_num = (max_value - min_value) // 3 + 1 buckets = [[] for _ in range(bucket_num)] # 2. 将数据分桶 并在桶内并排序 for k in lst: # 遍历列表中所有的数 i = k // 3 # i 表示 放到几号桶里 buckets[i].append(k) # 将数添加到桶里边 # 桶内排序 这里是插入排序 for j in range(len(buckets[i]) - 1, 0, -1): if buckets[i][j] &amp;lt; buckets[i][j - 1]: buckets[i][j], buckets[i][j - 1] = buckets[i][j - 1], buckets[i][j] else: break prev_length = 0 for i in range(bucket_num): cur_length = len(buckets[i]) for j in range(cur_length): lst[i * prev_length + j] = buckets[i][j] prev_length = cur_length 时间复杂度：</description>
    </item>
    
    <item>
      <title>Count</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/count/</link>
      <pubDate>Fri, 19 Aug 2022 14:37:12 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/count/</guid>
      <description>前言 计数排序，桶排序，和基数排序都需要额外的数据结构来辅助排序
def count_sort(lst, min_value, max_value): # 获取所需桶的数量 bucket_num = max_value - min_value + 1 # 构建初始桶 bucket = [0] * bucket_num # 统计元素数量，并存储在桶的对应位置 for i in lst: bucket[i - min_value] += 1 cur = 0 # 将桶中元素依次放回原数组，覆盖原数组元素 for j in range(bucket_num): for _ in range(bucket[j]): lst[cur] = j cur += 1 时间复杂度：
最优：$O(n+k)$
最坏：$O(n+k)$
平均：$O(n+k)$
空间复杂度： $O(k)$
稳定性： 稳定
额外提供一种稳定的计数排序Python实现
def count_sort(lst, min_value, max_value): # 获取所需桶的数量 bucket_num = max_value - min_value + 1 # 构建初始桶 bucket = [0] * bucket_num # 统计元素数量，并存储在桶的对应位置 for i in lst: bucket[i - min_value] += 1 for j in range(1, bucket_num): bucket[j] += bucket[j-1] result = [None] * len(lst) for k in range(len(lst) - 1, -1, -1): t = lst[k] - min_value bucket[t] -= 1 result[bucket[t]] = lst[k] return result </description>
    </item>
    
    <item>
      <title>堆排序</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/heap/</link>
      <pubDate>Fri, 19 Aug 2022 11:34:48 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/heap/</guid>
      <description>前言 堆排序是利用堆的数据结构完成排序的一种算法，堆可以理解为将它所有元素按照一个完全二叉树的顺序存储在数组中。
堆分为最大堆和最小堆，所有元素都小于它根节点的为最大堆。
因为元素都在数组中，所以元素$k_n$的左右子节点分别为$k_{2n+1}$和$k_{2n+2}$
核心思想 1、构建最大堆（从树的的最后一个非叶子节点元素到第一个元素，比较它和它左右子节点的值叶子节点小则交换位置）
2、步骤一完成后序列已满足最大堆，交换堆顶和堆尾元素，堆长度向后减少1，重复步骤一，直到堆没有叶子节点 3、如果一次循环中未发生元素交换，则序列已有序，可提前结束循环。
def heap_sort(lst): length = len(lst) while length &amp;gt; 1: for root in range(length // 2, -1, -1): left = 2 * root + 1 right = 2 * root + 2 if left &amp;lt; length and lst[left] &amp;gt; lst[root]: lst[root], lst[left] = lst[left], lst[root] if right &amp;lt; length and lst[right] &amp;gt; lst[root]: lst[root], lst[right] = lst[right], lst[root] length -= 1 lst[0], lst[length] = lst[length], lst[0] 时间复杂度：</description>
    </item>
    
    <item>
      <title>Merge</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/merge/</link>
      <pubDate>Thu, 18 Aug 2022 18:50:49 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/merge/</guid>
      <description>核心思想 1、递归分解序列至不可分
2、合并序列，合并的同时对序列排序
def merge_sort(lst): &amp;#34;&amp;#34;&amp;#34; 递归分解序列至不可分，再递归合并，合并的同时对序列排序， 使用两个指针分别遍历两个子序列，将元素按大小依次加入新的序列 &amp;#34;&amp;#34;&amp;#34; n = len(lst) if n &amp;lt;= 1: return mid = n // 2 left = lst[:mid] right = lst[mid:] merge_sort(left) merge_sort(right) left_idx = 0 right_idx = 0 lst[:] = [] while left_idx &amp;lt; len(left) and right_idx &amp;lt; len(right): if left[left_idx] &amp;lt;= right[right_idx]: lst.append(left[left_idx]) left_idx += 1 else: lst.append(right[right_idx]) right_idx += 1 lst += left[left_idx:] lst += right[right_idx:] 时间复杂度：
最优：$O(n\log_2n)$
最坏：$O(n\log_2n)$
平均：$O(n\log_2n)$</description>
    </item>
    
    <item>
      <title>Shell</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/shell/</link>
      <pubDate>Thu, 18 Aug 2022 18:44:42 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/shell/</guid>
      <description>核心思想 1、将序列按固定步长分组，组内进行插入排序 2、缩小步长，重复步骤一，直到步长小于等于1
def shell_sort(lst): n = len(lst) gap = n // 2 while gap &amp;gt;= 1: for i in range(gap, n): for j in range(i, 0, -gap): if lst[j] &amp;lt; lst[j - gap]: lst[j], lst[j - gap] = lst[j - gap], lst[j] else: break gap = gap // 2 时间复杂度：
最优：$O(n)$
最坏：$O(n^2)$
平均：$O(n^{1.3})$
空间复杂度： $O(1)$
稳定性： 不稳定</description>
    </item>
    
    <item>
      <title>Quick</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/quick/</link>
      <pubDate>Tue, 16 Aug 2022 17:59:35 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/quick/</guid>
      <description>核心思想 1、随机选择一个元素作为基准（一般选择第一个或最后一个元素），将序列按照基准切分成两份，大于基准的在后面，小于基准的在前面。
2、递归对切分的序列进行步骤1，直到序列不可分
def quick_sort(lst, head, tail): if head &amp;gt;= tail: return p = lst[head] start = head end = tail while start &amp;lt; end: while start &amp;lt; end and lst[end] &amp;gt;= p: end -= 1 lst[start] = lst[end] while start &amp;lt; end and lst[start] &amp;lt;= p: start += 1 lst[end] = lst[start] lst[end] = p quick_sort(lst, head, start - 1) quick_sort(lst, start + 1, tail) 时间复杂度：
最优：$O(n\log_2n)$
最坏：$O(n^2)$
平均：$O(n\log_2n)$</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/insert/</link>
      <pubDate>Tue, 16 Aug 2022 17:42:07 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/insert/</guid>
      <description>核心思想 1、定义一个已排序序列（初始一般指定第一个元素），将已排序序列后一个元素与已排序序列中每个元素从后往前比较，如果未排序元素小则交换，否则说明已经到正确位置，终止循环。
2、已排序序列范围向后增加1，重复步骤2，直到已排序序列长度等于原序列长度
def insert_sort(lst): &amp;#34;&amp;#34;&amp;#34;定义一个已排序序列，将剩余未排序序列依次插入到已排序序列&amp;#34;&amp;#34;&amp;#34; n = len(lst) for i in range(1, n): for j in range(i, 0, -1): if lst[j] &amp;lt; lst[j-1]: lst[j], lst[j-1] = lst[j-1], lst[j] else: break 时间复杂度：
最优：$O(n)$
最坏：$O(n^2)$
平均：$O(n^2)$
空间复杂度： $O(1)$
稳定性： 稳定</description>
    </item>
    
    <item>
      <title>Select</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/select/</link>
      <pubDate>Tue, 16 Aug 2022 17:31:02 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/select/</guid>
      <description>核心思想 1、遍历序列找到最小元素并记录，将最小元素与队列首元素交换
2、序列范围向前缩小1，重复步骤1
def select_sort(lst): n = len(lst) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if lst[j] &amp;lt; lst[min_idx]: min_idx = j lst[min_idx], lst[i] = lst[i], lst[min_idx] 时间复杂度：
最优：$O(n^2)$
最坏：$O(n^2)$
平均：$O(n^2)$
空间复杂度： $O(1)$
稳定性： 不稳定</description>
    </item>
    
    <item>
      <title>Bubble</title>
      <link>https://blog-zhanglaiya.vercel.app/algorithm/bubble/</link>
      <pubDate>Tue, 16 Aug 2022 17:11:26 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/algorithm/bubble/</guid>
      <description>核心思想 1、依次比较相邻元素，后面的比前面的小则交换元素，序列最后一个元素为最大元素
2、遍历长度缩小1，重复步骤一
3、如果一次循环中未发生元素交换，则序列已有序，可提前结束循环。
def bubble_sort(lst): n = len(lst) for j in range(1, n - 1): count = 0 for i in range(n - j): if lst[i] &amp;gt; lst[i+1]: lst[i], lst[i+1] = lst[i+1], lst[i] count += 1 if count == 0: break 时间复杂度：
最优：$O(n)$
最坏：$O(n^2)$
平均：$O(n^2)$
空间复杂度： $O(1)$
稳定性： 稳定</description>
    </item>
    
    <item>
      <title>斐波那契数列</title>
      <link>https://blog-zhanglaiya.vercel.app/posts/fibonacci/</link>
      <pubDate>Tue, 09 Aug 2022 19:11:54 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/posts/fibonacci/</guid>
      <description>问题 求斐波那契数列第$10^{19}$项的值，由于结果巨大，输出$mod$ $1000000007$的结果即可。
定义 前两项为1，从第三项开始都满足下面的公式
$$k_n = k_{n-1} + k_{n-2}$$ $$1,1,2,3,5,8,13\ldots$$
简单的python实现
def fib(n): a = 0 b = 1 for _ in range(n): a, b = b, a + b return a 可以看出，上面算法的时间复杂度是$O(n)$，可以说是比较优的方式了，但是当我在我的电脑上运行上面的代码求第$10^{19}$次项的值时，它很久都没有给我运行结果。
需要使用到斐波那契Q矩阵来减少运算次数
先介绍一下快速幂运算的概念
$x^2 = x × x$
$x^4 = x^2 × x^2$
$x^{100} = x^{64} × x^{32} × x^4$
观察上面的等式，$x^4$的计算如果用一次项乘4次需要计算3次，但是如果先计算2次项的平方则只需要计算2次。
同理，求$x^n$只需要计算$log2^n$次（实际操作是将低次项的结果保留起来，计算高次项时利用低次项的结果作为基础 ）
同时， $mod$运算也满足 $(A × B)$ % $C$ = $(A$ % $C)$ × $(B$ % $C)$</description>
    </item>
    
    <item>
      <title>第一篇blog</title>
      <link>https://blog-zhanglaiya.vercel.app/posts/my-first-post/</link>
      <pubDate>Mon, 08 Aug 2022 18:16:42 +0800</pubDate>
      
      <guid>https://blog-zhanglaiya.vercel.app/posts/my-first-post/</guid>
      <description>使用 hugo 设置我的博客 1、简单 2、方便 3、快速 今天使用hugo上线了我的博客了</description>
    </item>
    
  </channel>
</rss>
